/**
 * @module ContextChannels
 */

/* eslint-disable no-dupe-class-members */

import {EventEmitter} from 'events';

import {Identity} from 'openfin/_v2/main';

import {tryServiceDispatch, eventEmitter} from './connection';
import {APIFromClientTopic, ChannelTransport, DesktopChannelTransport} from './internal';
import {Context} from './context';
import {ContextListener} from './main';

export type ChannelId = string;

export const DEFAULT_CHANNEL_ID: ChannelId = 'default';

/**
 * Event fired when a window is added to a channel. See {@link Channel.addEventListener}.
 *
 * Note that this event will typically fire as part of a pair - since windows must always belong to a channel, a window
 * can only join a channel by leaving it's previous channel. The exceptions to this rule are when the window is created
 * and destroyed when there will be no previous channel or no current channel, respectively.
 *
 * @event
 */
export interface ChannelWindowAddedEvent {
    type: 'window-added';

    /**
     * The window that has just been added to the channel.
     */
    identity: Identity;

    /**
     * The channel that has been modified. Will always be the channel object that {@link Channel.addEventListener} was
     * called on.
     */
    channel: Channel;

    /**
     * The channel that the window belonged to previously.
     *
     * Will be `null` if this event is being fired on a newly-created window.
     */
    previousChannel: Channel|null;
}

/**
 * Event fired when a window is removed from a channel. See {@link Channel.addEventListener}.
 *
 * Note that this event will typically fire as part of a pair - since windows must always belong to a channel, a window
 * can only join a channel by leaving it's previous channel. The exceptions to this rule are when the window is created
 * and destroyed when there will be no previous channel or no current channel, respectively.
 *
 * To listen for channel changes across all (or multiple) channel, there is also a top-level {@link ChannelChangedEvent}.
 *
 * @event
 */
export interface ChannelWindowRemovedEvent {
    type: 'window-removed';

    /**
     * The window that has just been added to the channel.
     */
    identity: Identity;

    /**
     * The channel that the window now belongs to.
     *
     * Will be `null` if the window is leaving the channel due to it being closed.
     */
    channel: Channel|null;

    /**
     * The channel that has been modified. Will always be the channel object that {@link Channel.addEventListener} was
     * called on.
     */
    previousChannel: Channel;
}

/**
 * Event fired whenever a window changes channel. See {@link addEventListener}.
 *
 * This event can be used to track all channel changes, rather than listening only to a specific channel.
 *
 * See also {@link ChannelWindowAddedEvent}/{@link ChannelWindowRemovedEvent}
 *
 * @event 'channel'
 */
export interface ChannelChangedEvent {
    type: 'channel-changed';

    /**
     * The window that has switched channel.
     */
    identity: Identity;

    /**
     * The channel that the window now belongs to.
     *
     * Will be `null` if the window has just been closed, and so is being removed from a channel without being added to
     * another.
     */
    channel: Channel|null;

    /**
     * The previous channel that the window belonged to.
     *
     * Will be `null` if the window has just been created, and so doesn't have a previous channel.
     */
    previousChannel: Channel|null;
}

/**
 * @hidden
 */
export type ChannelEvent = ChannelWindowAddedEvent|ChannelWindowRemovedEvent;

export type Channel = DesktopChannel|DefaultChannel;

/**
 * Object representing a context channel.
 *
 * All interactions with a context channel happen through the methods on here.
 */
export abstract class ChannelBase {
    /**
     * Constant that uniquely identifies this channel. Will be generated by the service, and guarenteed to be unique
     * within the set of channels registered with the service.
     *
     * In the case of `desktop` channels (see {@link DesktopChannel}), these id's _should_ persist across sessions. The
     * channel list is defined by the service, but can be overridden by a desktop owner. If the desktop owner keeps
     * this list static (which is recommended), then id's will also persist across sessions.
     */
    public readonly id: ChannelId;

    /**
     * Uniquely defines each channel type.
     *
     * See overrides of this class for list of allowed values.
     */
    public readonly type: string;

    private eventEmitter: EventEmitter;
    private listeners: ContextListener[];

    protected constructor(id: string, type: string) {
        this.id = id;
        this.type = type;

        this.eventEmitter = new EventEmitter();
        this.listeners = [];
    }

    /**
     * Returns a list of all windows belonging to the specified channel.
     *
     * If the window making the call is a member of this channel, it will be included in the results.
     *
     * This will only include windows that contain context listeners. If there are no windows on this channel, an empty
     * array is returned.
     */
    public async getMembers(): Promise<Identity[]> {
        return tryServiceDispatch(APIFromClientTopic.CHANNEL_GET_MEMBERS, {id: this.id});
    }

    /**
     * Broadcasts the given context on this channel. This is equivilant to joining the channel and then calling the
     * top-level FDC3 `broadcast` function.
     *
     * Note that this function can be used without first joining the channel, allowing applications to broadcast on
     * channels that they aren't a member of.
     *
     * This broadcast will be received by all windows that are members of this channel, *except* for the window that
     * makes the broadcast. This matches the behaviour of the top-level FDC3 `broadcast` function.
     *
     * @param context The context to broadcast to all windows on this channel
     */
    public async broadcast(context: Context): Promise<void> {
        return tryServiceDispatch(APIFromClientTopic.CHANNEL_BROADCAST, {id: this.id, context});
    }

    /**
     * Returns the last context that was broadcast on this channel. All channels initially have no context, until a
     * window is added to the channel and then broadcasts. If there is not yet any context on the channel, this method
     * will return `null`. The context is also reset back into it's initial context-less state whenever a channel is
     * cleared of all windows.
     *
     * The context of a channel will be captured regardless of how the context is broadcasted on this channel - whether
     * using the top-level FDC3 `broadcast` function, or using the channel-level {@link broadcast} function on this
     * object.
     *
     * NOTE: Only non-default channels are stateful, for the default channel this method will always return `null`.
     */
    public async getCurrentContext(): Promise<Context|null> {
        return tryServiceDispatch(APIFromClientTopic.CHANNEL_GET_CURRENT_CONTEXT, {id: this.id});
    }

    /**
     * Adds the given window to this channel. If no identity is provided, the window making the call will be the window
     * added to the channel.
     *
     * If the channel has a current context (see {@link getCurrentContext}) then that context will be immediately passed to
     * the given window upon joining the channel, via its context listener(s).
     *
     * Note that all windows will always belong to exactly one channel at all times. If you wish to leave a channel, the
     * only way to do so is to re-join the default channel. This can be done by calling `channels.defaultChannel.join()`.
     *
     * @param identity The window that should be added to this channel. If omitted, will use the window that calls this method.
     */
    public async join(identity?: Identity): Promise<void> {
        return tryServiceDispatch(APIFromClientTopic.CHANNEL_JOIN, {id: this.id, identity});
    }

    /**
     * Event that is fired whenever a window broadcasts on this channel.
     *
     * This can be triggered by a window belonging to the channel calling the top-level FDC3 `brodcast` function, or by
     * any window calling this channel's {@link Channel.broadcast} method.
     *
     * @param handler Function that should be called whenever a context is broadcast on this channel
     */
    public addBroadcastListener(handler: (context: Context) => void): ContextListener {
        const listener = {
            handler,
            unsubscribe: () => {
                const index: number = this.listeners.indexOf(listener);

                if (index >= 0) {
                    this.listeners.splice(index, 1);
                }

                return index >= 0;
            }
        };
        this.listeners.push(listener);
        return listener;
    }

    /**
     * Event that is fired whenever a window changes joins this channel. This includes switching to/from the default
     * channel.
     *
     * The event also includes which channel the window was in previously. The `channel` property within the
     * event will always be this channel instance.
     */
    public addEventListener(eventType: 'window-added', listener: (event: ChannelWindowAddedEvent) => void): void;

    /**
     * Event that is fired whenever a window changes leaves this channel. This includes switching to/from the default
     * channel.
     *
     * The event also includes which channel the window is being added to. The `previousChannel` property within the
     * event will always be this channel instance.
     */
    public addEventListener(eventType: 'window-removed', listener: (event: ChannelWindowRemovedEvent) => void): void;

    public addEventListener<E extends ChannelEvent>(eventType: E['type'], listener: (event: E) => void): void {
        if (typeof fin === 'undefined') {
            throw new Error('fin is not defined. The openfin-fdc3 module is only intended for use in an OpenFin application.');
        }

        this.eventEmitter.addListener(eventType, listener);
    }

    public removeEventListener(eventType: 'window-added', listener: (event: ChannelWindowAddedEvent) => void): void;
    public removeEventListener(eventType: 'window-removed', listener: (event: ChannelWindowRemovedEvent) => void): void;

    /**
     * Removes a listener previously added with {@link addEventListener}.
     *
     * Has no effect if `eventType` isn't a valid event, or `listener` isn't a callback registered against `eventType`.
     *
     * @param eventType The event being unsubscribed from
     * @param listener The callback function to remove
     */
    public removeEventListener<E extends ChannelEvent>(eventType: E['type'], listener: (event: E) => void): void {
        if (typeof fin === 'undefined') {
            throw new Error('fin is not defined. The openfin-fdc3 module is only intended for use in an OpenFin application.');
        }

        this.eventEmitter.addListener(eventType, listener);
    }
}

/**
 * User-facing channels, to display within a colour picker or channel selector component.
 *
 * This list of channels should be considered fixed by applications - the service will own the list of user channels,
 * making the same list of channels available to all applications, and this list will not change over the lifecycle of
 * the service.
 *
 * We do not intend to support creation of 'user' channels at runtime, as this then adds considerable complexity when
 * implementing a channel selector component (must now support events, 'create channel' UI, reflowing of channel
 * list, etc).
 */
export class DesktopChannel extends ChannelBase {
    public readonly type!: 'desktop';

    /**
     * A user-readable name for this channel, e.g: `"Red"`
     */
    public readonly name: string;

    /**
     * The color that should be associated within this channel when displaying this channel in a UI, e.g: `0xFF0000`.
     */
    public readonly color: number;

    public constructor(transport: DesktopChannelTransport) {
        super(transport.id, 'desktop');

        this.name = transport.name;
        this.color = transport.color;
    }
}

/**
 * All windows will start off in this channel.
 *
 * Unlike desktop channels, the default channel has no pre-defined name or visual style. It is up to apps to display
 * this in the channel selector as they see fit - it could be as "default", or "none", or by "leaving" a user channel.
 */
export class DefaultChannel extends ChannelBase {
    public readonly type!: 'default';

    public constructor() {
        super(DEFAULT_CHANNEL_ID, 'default');
    }
}

/**
 * The channel in which all windows will initially be placed.
 *
 * All windows that have a context listener will always belong to exactly one channel at all times. If they have not
 * explicitly been placed into a channel via a {@link Channel.join} call, they will be in this channel.
 *
 * If an app wishes to leave a named channel, it can do so by (re-)joining this channel.
 */
export const defaultChannel: DefaultChannel = new DefaultChannel();

/**
 * Fetches a channel object for a given channel identifier. The `channelId` property maps to the {@link Channel.id} field.
 *
 * TODO (SERVICE-429): Decide what happens if calling with an invalid channel ID. Will the client know it's
 * invalid?.. Also, what if desktop channel list hasn't yet been fetched from provider? (may need to be made async).
 * @param channelId The ID of the channel to fetch.
 */
export async function getChannelById(channelId: ChannelId): Promise<Channel|null> {
    return channelLookup[channelId] || null;
}

/**
 * Gets all user-visible channels.
 *
 * This is the list of channels that should be used to populate a channel selector. All channels returned will have
 * additional metadata that can be used to populate a selector UI with a consistent cross-app channel list.
 */
export async function getDesktopChannels(): Promise<DesktopChannel[]> {
    const channelData: ChannelTransport[] = await tryServiceDispatch(APIFromClientTopic.GET_DESKTOP_CHANNELS, {});

    return channelData.map(getChannelObject) as DesktopChannel[];
}

/**
 * Returns the channel that the current window is assigned to.
 *
 * @param identity The window to query. If omitted, will use the window that calls this method.
 * @throws `FDC3Error`: If `identity` is not a valid {@link https://developer.openfin.co/docs/javascript/stable/global.html#Identity | Identity}
 * @throws `FDC3Error`: If the window specified by `identity` does not exist
 * @throws `FDC3Error`: If the window specified by `identity` does not integrate FDC3 (determined by inclusion of the client API module)
 */
export async function getCurrentChannel(identity?: Identity): Promise<Channel> {
    const channelData: ChannelTransport = await tryServiceDispatch(APIFromClientTopic.GET_CURRENT_CHANNEL, {identity});

    return getChannelObject(channelData);
}

/**
 * Event that is fired whenever a window changes from one channel to another.
 *
 * Note that this listener applies to all windows and channels. Check the properties on the event to see which window
 * and channels were modified.
 */
export function addEventListener(eventType: 'channel-changed', handler: (event: ChannelChangedEvent) => void): void;

export function addEventListener<E extends ChannelEvent>(eventType: E['type'], handler: (event: E) => void): void {
    eventEmitter.addListener(eventType, handler);
}

export function removeEventListener(eventType: 'channel-changed', handler: (event: ChannelChangedEvent) => void): void;

/**
 * Removes a listener previously added with {@link addEventListener}.
 *
 * Has no effect if `eventType` isn't a valid event, or `listener` isn't a callback registered against `eventType`.
 *
 * @param eventType The event being unsubscribed from
 * @param listener The callback function to remove
 */
export function removeEventListener<E extends ChannelEvent>(eventType: E['type'], handler: (eventPayload: E) => void): void {
    eventEmitter.removeListener(eventType, handler);
}

const channelLookup: {[id: string]: Channel} = {
    [DEFAULT_CHANNEL_ID]: defaultChannel
};
function getChannelObject<T extends Channel = Channel>(data: ChannelTransport): T {
    let channel: Channel = channelLookup[data.id];

    if (!channel) {
        switch (data.type) {
            case 'default':
                channel = defaultChannel;
                break;
            case 'desktop':
                channel = new DesktopChannel(data as DesktopChannelTransport);
        }
    }

    return channel as T;
}
